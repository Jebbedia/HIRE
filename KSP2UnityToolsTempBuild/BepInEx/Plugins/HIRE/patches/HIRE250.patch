@new("HIRE250")
:parts {

    /*
      +-----------+
      | Meta data |
      +-----------+
    */

    /* The name of the person or people working on the part */
    author: "Rafael Aeronautics";

    /*
      +-------------+
      | Descriptors |
      +-------------+
    */

    category: "Engine";
    family: "";
    childStageOffset: 0;
    cost: 100;
    crewCapacity: 0;
    stageOffset: 0;
    isCompound: false;
    sizeCategory: "M";
    stageType: "LiquidEngine";
    resourceCosts: [];
    tags: "launch propuls rocket";
    stagingIconAssetAddress: "Staging-Engines/Staging-ICO-Methalox.png";
    PartSizeDiameter: 2.5;

    /*
      +------------+
      | Properties |
      +------------+
    */

    angularDrag: 2.0;
    breakingForce: 5.0;
    breakingTorque: 5.0;
    buoyancy: 1.0;
    buoyancyUseSine: true;
    coLiftOffset: {
        x: 0.0,
        y: 0.0,
        z: 0.0
    };
    coMassOffset: {
        x: 0.0,
        y: 0.5,
        z: 0.0
    };
    coPressureOffset: {
        x: 0.0,
        y: 0.0,
        z: 0.0
    };
    coBuoyancy: {
        x: 0.0,
        y: 0.0,
        z: 0.0
    };
    coDisplacement: {
        x: 0.0,
        y: 0.0,
        z: 0.0
    };
    crashTolerance: 2.0;
    explosionPotential: 1.25;
    fuelCrossFeed: true;
    heatConductivity: 0.0;
    mass: 2.0;
    maxTemp: 17.0;
    attachRules: {
        stack: true,
        srfAttach: false,
        allowStack: true,
        allowSrfAttach: false,
        allowCollision: false,
        allowDock: false,
        allowRotate: true,
        allowRoot: false
    };
    attachNodes: [{
        nodeID: "top",
        NodeSymmetryGroupID: "",
        nodeType: "Stack",
        attachMethod: "FIXED_JOINT",
        IsMultiJoint: false,
        MultiJointMaxJoint: 0,
        MultiJointRadiusOffset: 0.0,
        MultiJointOnSingleAxis: false,
        SingleJointAxis: "X",
        MultiJointFullBreakStrength: false,
        position: {
            x: 0.0,
            y: 1.05,
            z: 0.0
        },
        orientation: {
            x: 0.0,
            y: 1.0,
            z: 0.0
        },
        size: 1,
        visualSize: 1.0,
        isResourceCrossfeed: true,
        isRigid: true,
        angularStrengthMultiplier: 1.0,
        contactArea: 0.0,
        overrideDragArea: 0.0,
        isCompoundJoint: false
    }, {
        nodeID: "bottom",
        NodeSymmetryGroupID: "",
        nodeType: "Stack",
        attachMethod: "FIXED_JOINT",
        IsMultiJoint: false,
        MultiJointMaxJoint: 0,
        MultiJointRadiusOffset: 0.0,
        MultiJointOnSingleAxis: false,
        SingleJointAxis: "X",
        MultiJointFullBreakStrength: false,
        position: {
            x: 0.0,
            y: 0.0,
            z: 0.0
        },
        orientation: {
            x: 0.0,
            y: -1.0,
            z: 0.0
        },
        size: 1,
        visualSize: 1.0,
        isResourceCrossfeed: true,
        isRigid: true,
        angularStrengthMultiplier: 1.0,
        contactArea: 0.0,
        overrideDragArea: 0.0,
        isCompoundJoint: false
    }];
    AllowKinematicPhysicsIfIntersectTerrain: false;
    resourceSummary: {
        Consumes: [],
        Generates: [],
        Contains: []
    };

    /*
      +-------------------------+
      | Parts Manager Overrides |
      +-------------------------+
    */

    PAMModuleSortOverride: [];
    PAMModuleVisualsOverride: [];

    /*
      +--------+
      | Editor |
      +--------+
    */

    collisionVolumeBoundsScale: {
        x: 1.0,
        y: 1.0,
        z: 1.0
    };

    /*
      +-----------------------+
      | Captured but unsorted |
      +-----------------------+
    */

    emissiveConstant: 0.0;
    maximumDrag: 0.2;
    minimumDrag: 0.2;
    physicsMode: "Full";
    inverseStageCarryover: false;
    skinMassPerArea: 0.0;
    bodyLiftOnlyUnattachedLift: false;
    bodyLiftOnlyAttachName: "";
    maxLength: 0;
    radiatorHeadroom: 0.0;
    radiatorMax: 0.0;
    skinMaxTemp: 0.0;
    skinInternalConductionMult: 0.0;
    thermalMassModifier: 0.85;
    buoyancyUseCubeNamed: "";
    HasReportStorage: false;

    /*
      +--------------+
      | OAB Settings |
      +--------------+
    */

    oabEditorCategory: "VAB";
    partType: "Rocket";
    /* Allows a part to specify what orientation it considers its primary. The mode specified will see the part oriented similarly to how it is in the prefab by default. The part will try to maintain this orientation regardless of VAB mode. */
    PreferredOrientation: "NONE";
    /* Allows specifying what type of mirror logic is used for this part. May impact how other parts interact with it. The Auto setting is configurable on OAB.prefab */
    MirrorTechnique: "RotationYZ";
    /* Based on all of the other settings, from orientation preference to mirror technique and category, suggest a rotation for this part only if no use rotation is provided. By default, no suggestions are made. */
    CanSuggestOrientation: false;
    /* Offset at which the player cursor "grabs" the part when in OAB */
    PickUpPointOffset: {
        x: 0.0,
        y: 0.0,
        z: 0.0
    };
    /* Offset at which the part is rotated in the OAB when the player is grabbing a part */
    PickupRotationPointOffset: {
        x: 0.0,
        y: 0.0,
        z: 0.0
    };
    _title: null;
    _subtitle: null;
    _description: null;
    _manufacturer: null;

    /*
      +-----------------------+
      | Resources and Modules |
      +-----------------------+
    */

    * > resourceContainers {
    }
    +Module_Gimbal {
        +Data_Gimbal {
            gimbalTransformName: "gimbal";
            forceProceduralGimbaling: false;
            gimbalRange: 1.0;
            gimbalResponseSpeed: 1.0;
            useGimbalResponseSpeed: true;
            gimbalRangeXP: -1.0;
            gimbalRangeXN: -1.0;
            gimbalRangeYP: -1.0;
            gimbalRangeYN: -1.0;
            minRollOffset: 0.1;
            xMult: 1.0;
            yMult: 1.0;
            pitchValueName: "fPitch";
            flipAnimatedPitchAxis: false;
            yawValueName: "fYaw";
            flipAnimatedYawAxis: false;
            movementAudioThreshold: 0.1;
        }
    }
    +Module_Engine {
        +Data_Engine {
            +Engine {
                /*
                  The Engine ID display name, should be a localization tag to get localized engine mode in the UI.
                  This only appears in the UI for multi-mode engines.
                */
                EngineDisplayName: "Engine";
                /*
                  The Thrust Transform name in the model for this engine mode.
                  This is only used to find the thrust transforms if ThrustTransformNamesMultipliers list below is left empty.
                */
                thrustVectorTransformName: "thrustTransform";
                /*
                  The Thrust Transform names and Thrust multipliers in the model for this engine mode.
                  This will override the thrustVectorTransformName field above.
                */
                ThrustTransformNamesMultipliers: [];
                /* Is the throttle locked in this engine mode? EG: SRB or can be changed by the player. */
                throttleLocked: false;
                /*
                  When will the engine fail from lack of propellants?
                  Default = 0.1 or at 10% of required fuel or less the engine flames out.
                */
                ignitionThreshold: 0.01;
                /* Do we clamp the return percent to the min ratio (and never request more on followups) or do we request all always, and average? */
                clampPropReceived: false;
                clampPropReceivedMinLowerAmount: 0.999;
                /* Can the engine be restarted in this mode? eg: SRB would be false. */
                allowRestart: true;
                /* Can the engine be shut down in this mode? eg: SRB would be false. */
                allowShutdown: true;
                /* Can the engine be be activated when shielded from airstream? ie: inside a fairing? */
                shieldedCanActivate: true;
                /* A curve to determine loss or gain of thrust due to changes in atmosphere vs vacuum values are based on ISP to ATM Pressure */
                atmosphereCurve: {
                    fCurve: {
                        keys: [{
                            time: -0.0011360487,
                            value: 360.104584,
                            inTangent: -39.81015,
                            outTangent: -39.81015,
                            inWeight: 0.0,
                            outWeight: 0.333333343,
                            weightedMode: "None",
                            tangentMode: 34
                        }, {
                            time: 1.002716,
                            value: 320.141083,
                            inTangent: -51.97571,
                            outTangent: -51.97571,
                            inWeight: 0.333333343,
                            outWeight: 0.333333343,
                            weightedMode: "None",
                            tangentMode: 34
                        }, {
                            time: 5.994493,
                            value: -0.0378303528,
                            inTangent: -64.14127,
                            outTangent: -64.14127,
                            inWeight: 0.333333343,
                            outWeight: 0.0,
                            weightedMode: "None",
                            tangentMode: 34
                        }],
                        length: 3,
                        preWrapMode: "ClampForever",
                        postWrapMode: "ClampForever"
                    },
                    _minTime: 340282347.0,
                    _maxTime: -340282347.0
                };
                /* should we use a thrust curve (based on resource remaining) ? */
                useThrustCurve: false;
                /* The thrust curve to use if useThrustCurve is true. */
                thrustCurve: {
                    fCurve: {
                        keys: [{
                            time: 0.0,
                            value: 1.0,
                            inTangent: 0.0,
                            outTangent: 0.0,
                            inWeight: 0.0,
                            outWeight: 0.0,
                            weightedMode: "None",
                            tangentMode: 34
                        }, {
                            time: 1.0,
                            value: 1.0,
                            inTangent: 0.0,
                            outTangent: 0.0,
                            inWeight: 0.0,
                            outWeight: 0.0,
                            weightedMode: "None",
                            tangentMode: 34
                        }],
                        length: 2,
                        preWrapMode: "ClampForever",
                        postWrapMode: "ClampForever"
                    },
                    _minTime: 340282347.0,
                    _maxTime: -340282347.0
                };
                /* Is this engine disabled when under water? */
                disableUnderwater: false;
                /* If set to true this engine mode will not be included in Delta-V calculations. */
                nonThrustMotor: false;
                /* Minimum Thrust in kN this engine produces at 0% throttle. */
                minThrust: 0.0;
                /* Maximum Thrust in kN this engine produces at 100% throttle. */
                maxThrust: 22.0;
                /* What type of engine is this? */
                engineType: "Methalox";
                propellant: {
                    ingredientOverrides: [],
                };
                /* Whether to apply the engine acceleration and deceleration speed variables. */
                useEngineResponseTime: false;
                /* How quickly the engine can increase its thrust production, as a fraction of maximum/second. */
                engineAccelerationSpeed: 0.01;
                /* How quickly the engine can decrease its thrust production, as a fraction of maximum/second. */
                engineDecelerationSpeed: 0.01;

                /*
                  +----------------+
                  | Heat Variables |
                  +----------------+
                */

                /* Does this engine generate heat at all? */
                GenerateHeat: false;
                /*
                  Curve to adjust heat produced based on atmosphere pressure key (coordinate)
                  X: Atmospheric Pressure.  1 = Kerbin Atmosphere at sea level.
                  Y: Defines the heat production  at the given atmosphere of pressure.
                */
                HeatAtmosphereCurve: {
                    fCurve: {
                        keys: [],
                        length: 0,
                        preWrapMode: "ClampForever",
                        postWrapMode: "ClampForever"
                    },
                    _minTime: 340282347.0,
                    _maxTime: -340282347.0
                };
                /*
                  Do we divide the heat produced by the flow multiplier to get the final flux?
                  i.e. do we always produce the same heat for the same throttle setting?
                */
                NormalizeHeatForFlow: true;

                /*
                  +--------------------------+
                  | Exhaust Damage Variables |
                  +--------------------------+
                */

                /* Determines whether the engine heats up and pushes on parts that are arranged in its exhaust path. */
                exhaustDamage: true;
                /*
                  A multiplier to the exhaust damage radius.
                  The radius is calculated from the Part Size category * this multiplier
                */
                exhaustDamageRadiusMultiplier: 1.0;
                /* The amount of heat added from exhaust to a part, in kW. */
                ExhaustDamageValue: 165.0;
                /* Whether damage from the engine exhaust is logged for debugging. */
                exhaustDamageLogEvent: false;
                /* Whether the engine will receive heating from the exhaust splashing back. */
                exhaustSplashbackDamage: true;
                /* Adjusts the exponent of the exhaust damage distance falloff curve. */
                exhaustDamageFalloffPower: 1.0;
                /* Adjusts the exponent of the exhaust splashback damage distance  falloff curve. */
                exhaustDamageSplashbackFallofPower: 2.5;
                /* Adjusts the splashback damage multiplier per Newton of force produced. */
                exhaustDamageSplashbackMult: 0.0;
                /* The maximum amount of splashback damage that can occur. */
                exhaustDamageSplashbackMaxMutliplier: 1.0;
                /* Distance from the thrust transform where exhaust damage starts to occur. */
                exhaustDamageDistanceOffset: 0.0;
                /* Maximum range in meters that the exhaust damage is applied. */
                exhaustDamageMaxRange: 1.0;
                /* Cap on the maximum multiplier to above factors that the exhaust damage can be at. */
                exhaustDamageMaxMutliplier: 1.0;

                /*
                  +-----------------------------+
                  | Exhaust Shockwave Variables |
                  +-----------------------------+
                */

                /* Whether this engine creates a shockwave. */
                exhaustShockwave: false;
                /* Whether damage from shockwave events are logged for debugging. */
                exhaustShockwaveLogEvent: false;
                /* Period of time between shockwaves. A value of -1 means this shockwave always occurs. */
                exhaustShockwaveInterval: -1.0;
                /* Adjusts the force in Newtons a shockwave produces for damage purposes. */
                exhaustShockwaveMultiplier: 1.0;
                /* Adjusts the exponent of the shockwave damage distance falloff curve. */
                exhaustShockwaveFalloffPower: 1.0;
                /* Distance from the thrust transform that the shockwave starts. */
                exhaustShockwaveDistanceOffset: 0.0;
                /* Maximum range in meters that shockwave damage is applied. */
                exhaustShockwaveMaxRange: 1.0;
                /* Cap on the maximum multiplier that shockwave damage can be at. */
                exhaustShockwaveMaxMultiplier: 1.0;

                /*
                  +-----------------------------+
                  | AlternateThrottle Variables |
                  +-----------------------------+
                */

                throttleUseAlternate: false;
                throttleResponseRate: -1.0;
                throttleIgniteLevelMult: 1.0;
                throttleStartupMult: 1.0;
                throttleStartedMult: 1.0;
                throttleInstantShutdown: true;
                throttleShutdownMult: 1.0;
                throttleInstant: false;
                throttlingBaseRate: 1.0;
                throttlingBaseClamp: 1.1;
                throttlingBaseDivisor: 0.2;

                /*
                  +---------------+
                  | Jet Variables |
                  +---------------+
                */

                /* Atmospheric density will change fuel flow (and thus thrust) */
                atmChangeFlow: false;
                /*
                  Normally thrust is proportional to density, but we allow tuning.
                  Tuning is especially needed because there's no stratosphere, so temperature keeps decreasing and thus speed of sound keeps decreasing.
                */
                atmCurve: {
                    fCurve: {
                        keys: [],
                        length: 0,
                        preWrapMode: "ClampForever",
                        postWrapMode: "ClampForever"
                    },
                    _minTime: 340282347.0,
                    _maxTime: -340282347.0
                };
                /* Do we use the atm curve? If not, and atmChangeFlow is true, just use atm linearly. */
                useAtmCurve: false;
                /*
                  replacement for the existing module's velocityCurve.
                  Note that its x value is Mach, not m/s velocity.
                  High-bypass turbofans will see thrust decrease steadily from static.
                  Low-bypass turbofans and turbojets will see thrust decrease slightly up to about 0.2 Mach then increase steadily until the limit is reached (both in terms of heat, and incoming compression vs compressor compression).
                  Ramjets have 0 static thrust, and do not light until 0.3 Mach or so, but once lit have steadily increasing thrust until Mach 5, when the incoming air can no longer be slowed to subsonic (combustion must be subsonic for ramjets). Thermal limits also apply, of course.
                */
                velCurve: {
                    fCurve: {
                        keys: [],
                        length: 0,
                        preWrapMode: "ClampForever",
                        postWrapMode: "ClampForever"
                    },
                    _minTime: 340282347.0,
                    _maxTime: -340282347.0
                };
                /* If false, we don't use the new velCurve above. */
                useVelCurve: false;
                /* tunable clamp. The flow multiplier will never go below this. */
                CLAMP: 0.00001;
                /* Same as atmCurve, but changes Isp not flow */
                atmCurveIsp: {
                    fCurve: {
                        keys: [],
                        length: 0,
                        preWrapMode: "ClampForever",
                        postWrapMode: "ClampForever"
                    },
                    _minTime: 340282347.0,
                    _maxTime: -340282347.0
                };
                /* Whether to use the atmCurveIsp curve above. */
                useAtmCurveIsp: false;
                /* Same as velCurve but changes Isp not flow. */
                velCurveIsp: {
                    fCurve: {
                        keys: [],
                        length: 0,
                        preWrapMode: "ClampForever",
                        postWrapMode: "ClampForever"
                    },
                    _minTime: 340282347.0,
                    _maxTime: -340282347.0
                };
                /* Whether to use the velCurveIsp curve above. */
                useVelCurveIsp: false;
                /* When the flow multiplier goes below this, we Flameout the engine. NOTE: THIS FIXES ASYMMETRIC FLAMEOUTS. */
                flameoutBar: 0.07;
                /* cap beyond which increases to flow multiplier aren't fully felt (start to taper off) */
                flowMultCap: 340282347.0;
                /* Sharpness of the tapering off of flow increase beyond cap. */
                flowMultCapSharpness: 2.0;
                /* Multiplier to final flow as calculated. */
                multFlow: 1.0;
                /* Multiplier to final Isp as calculated. */
                multIsp: 1.0;

                /*
                  +-------------------+
                  | Turbine Variables |
                  +-------------------+
                */

                /* This is the Turbine Spool Up time used for Spool Up Engine FX. */
                engineSpoolTime: 2.0;
                engineSpoolIdle: 0.05;

                /*
                  +---------------------+
                  | Wait Time Variables |
                  +---------------------+
                */

                /* The time to wait when exiting this engine mode in seconds. */
                ModeExitWaitTime: 0.0;
                /* The time to wait when exiting running state in this engine mode in seconds. */
                ModeExitRunningWaitTime: 0.0;
                /* The time to wait when entering this engine mode in seconds. */
                ModeEnterWaitTime: 0.0;
                /* The time to wait when entering running state in this engine mode in seconds. */
                ModeEnterRunningWaitTime: 0.0;
                /* The time to wait when deactivating this engine mode in seconds. */
                DeactivateEngineWaitTime: 0.0;
                /* The time to wait when activating this engine mode in seconds. */
                ActivateEngineWaitTime: 0.0;
                /* Set this to true will run the Deploy/Retract animation on Activation and Deactivation of the engine. */
                RunAnimationOnActivateDeactivate: false;

                /*
                  +-----------------+
                  | Other Variables |
                  +-----------------+
                */

                /* Should we use the Throttle ISP curve? */
                useThrottleIspCurve: false;
                /*
                  Modifies Isp based on throttle.
                  Time is pressure in atm, value is how much throttling affects Isp
                  (i.e. Isp = input * Lerp(1, throttleIspCurve, throttleIspCurveAtmStrength)
                */
                throttleIspCurveAtmStrength: {
                    fCurve: {
                        keys: [],
                        length: 0,
                        preWrapMode: "ClampForever",
                        postWrapMode: "ClampForever"
                    },
                    _minTime: 340282347.0,
                    _maxTime: -340282347.0
                };
                /* Modifies Isp based on throttle. time is throttle, value is multiplier to Isp */
                throttleIspCurve: {
                    fCurve: {
                        keys: [],
                        length: 0,
                        preWrapMode: "ClampForever",
                        postWrapMode: "ClampForever"
                    },
                    _minTime: 340282347.0,
                    _maxTime: -340282347.0
                };
            }

            UseEmissive: false;
            EmissiveMaterialNames: [];
            EmissiveTemperatureCurve: {
                fCurve: {
                    keys: [],
                    length: 0,
                    preWrapMode: "ClampForever",
                    postWrapMode: "ClampForever"
                },
                _minTime: 340282347.0,
                _maxTime: -340282347.0
            };
            EmissiveLerpRateUp: 0.1;
            EmissiveLerpRateDown: 0.01;
            DeployedModeAnimationStateShortName: "OPENED";
        }
    }
    +Module_ResourceConverter {
        +Data_ResourceConverter {
            ToggleName: "PartModules/ResourceConverter/Enabled";
            StartActionName: "PartModules/ResourceConverter/StartConverter";
            StopActionName: "PartModules/ResourceConverter/StopConverter";
            ToggleActionName: "PartModules/ResourceConverter/ToggleConverter";
            ConvertByMass: false;
            ResourceAutoShutdown: false;
            FormulaDefinitions: [{
                InternalName: "Active Heatshield Cooling",
                FormulaLocalizationKey: "",
                InputResources: [{
                    Rate: 0.001,
                    ResourceName: "Methalox",
                    AcceptanceThreshold: 0.0
                }, {
                    Rate: 0.002,
                    ResourceName: "ElectricCharge",
                    AcceptanceThreshold: 0.0
                }],
                OutputResources: [{
                    Rate: 0.005,
                    ResourceName: "Ablator",
                    AcceptanceThreshold: 0.0
                }],
                FluxGenerated: 0.0,
                AcceptanceThreshold: 0.0
            }];
            ThermalAutoShutdown: false;
            AutoShutdownTemperature: 2.0;
            SafeOperationTemperature: 1.0;
            UseEmissive: false;
            UseEmissiveTemperature: false;
            EmissiveMaterialNames: [];
            EmissiveTemperatureCurve: {
                fCurve: {
                    keys: [],
                    length: 0,
                    preWrapMode: "ClampForever",
                    postWrapMode: "ClampForever"
                },
                _minTime: 340282347.0,
                _maxTime: -340282347.0
            };
            EmissiveLerpRateUp: 0.1;
            EmissiveLerpRateDown: 0.01;
        }
    }
    +Module_Drag {
        +Data_Drag {
            BodyLiftEnabled: true;
            DragEnabled: true;
            bodyLiftMultiplier: 1.0;
            cubes: [];
            weightedArea: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
            weightedExposedArea: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
            weightedDrag: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
            weightedDragMultiplier: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
            weightedDepth: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
            weightedCenter: {
                x: 0.0,
                y: 0.0,
                z: 0.0
            };
            weightedSize: {
                x: 0.0,
                y: 0.0,
                z: 0.0
            };
            isDragCubeRotated: false;
            dragCubeRotation: {
                x: 0.0,
                y: 0.0,
                z: 0.0,
                w: 1.0
            };
        }
    }
    +Module_Heatshield {
        +Data_Heatshield {
            requiredResources: [];
            AblationTempThreshold: 6.0;
            AblationMaximumOverThreshold: 5.0;
            PyrolysisLossFactor: 1.0;
            ShieldingScale: 1.0;
            ShieldingDirection: {
                x: 0.0,
                y: -1.0,
                z: 0.0
            };
            DisabledWhenRetracted: true;
            UseChar: true;
            CharMaterialName: "";
            CharMin: 0.1;
            CharMax: 0.85;
        }
    }
    +Module_Deployable {
        +Data_Deployable {
            showStatus: true;
            isTracking: true;
            applyShielding: true;
            applyShieldingExtend: true;
            retractable: true;
            extendable: true;
            TrackingAlignmentOffset: 0.0;
            trackingSpeed: 0.25;
            EditorAnimSpeedMul: 1.0;
            pivotName: "";
            alignType: "";
            secondaryTransform: "";
            animationName: "";
            trackingMode: "None";
            originalRotation: {
                x: 0.0,
                y: 0.0,
                z: 0.0,
                w: 0.0
            };
            currentRotation: {
                x: 0.0,
                y: 0.0,
                z: 0.0,
                w: 0.0
            };
            targetGUID: "myTargetGUID";
            LimitRotation: false;
            UseDeployLimit: false;
            AxisMinMaxRotation: {
                x: -18.0,
                y: 18.0
            };
            DefaultActionGroup: "None";
            deployCrashTolerance: 1.0;
            deployMaxTemp: 2.0;
            deployBreakingForce: 2.0;
            deployBreakingTorque: 2.0;
            /* Set this to true will disable the animator when it is inactive. Need this set to true for WHEELS and LANDING LEGS! */
            DisableAnimatorWhenInactive: false;
            DeployPartTypeName: "PartModules/Deployable/PartType";
            OneTimeExtendActionName: "PartModules/Deployable/ExtendOnly";
            DeployToggleActionName: "PartModules/Deployable/Toggle";
            ActionGroupToggleName: "PartModules/Deployable/ToggleExtended/Toggle";
            ActionGroupExtendName: "PartModules/Deployable/ToggleExtended/Extend";
            ActionGroupRetractName: "PartModules/Deployable/ToggleExtended/Retract";
            DeployStateRetractedName: "PartModules/Deployable/State/Retracted";
            DeployStateExtendedName: "PartModules/Deployable/State/Extended";
            DeployStateMovingName: "PartModules/Deployable/State/Moving";
            DeployStateBlockedName: "PartModules/Deployable/State/Blocked";
            DeployStateExtendedCannotRetractName: "PartModules/Deployable/State/CannotRetract";
            DeployRetractedCannotRetractName: "PartModules/Deployable/State/RetractedCannotRetract";
        }
    }
    +Module_Fairing {
        +Data_Fairing {

            /*
              +---------------+
              | Floating node |
              +---------------+
            */

            /* The attach node size of the floating node */
            FloatingNodeSize: 1.0;
            /* Attach node tag that will be given to the dynamic attach node */
            FloatingAttachNodeTag: "bottom";
            /* Local position of the floating node relative to the part */
            FloatingNodePosition: {
                x: 0.0,
                y: 0.0,
                z: 0.0
            };
            /* Local direction that the floating node moves when the Length value is changed */
            FloatingNodeDirection: {
                x: 0.0,
                y: -1.0,
                z: 0.0
            };
            /* Whether the floating attach node will produce a multi-joint connection */
            FloatingNodeIsMultiJoint: true;
            /* If FloatingNodeIsMultiJoint, the amount of joints the array should have */
            FloatingNodeMultiJointMaxCount: 3;
            /* If FloatingNodeIsMultiJoint, the distance between joints. Does nothing otherwise */
            FloatingNodeMultiJointOffset: 1.0;

            /*
              +---------------------------------+
              | Fairing construction parameters |
              +---------------------------------+
            */

            /* ID of the attach node, other than the floater, that will yield an automatic fairing */
            FairingNode: "bottom";
            /* How "pointy" the cap panel is */
            NoseTip: 0.5;
            /* Roughness of the sides of the mesh. */
            EdgeWarp: 0.02;
            /* Max steepness to prevent normal artifacting in the mesh */
            AberrantNormalLimit: 45.0;
            /* The "up" direction of the fairing */
            LocalUpAxis: {
                x: 0.0,
                y: 1.0,
                z: 0.0
            };
            /* The relative center of the procedural mesh */
            Pivot: {
                x: 0.0,
                y: 0.0,
                z: 0.0
            };
            /* Name of the base object */
            BaseModelTransformName: "Base";
            /* Max radius of the cap */
            CapRadius: 0.375;
            /* Radius of the base object */
            BaseRadius: 1.25;
            CloseRadius: 0.375;
            /* Max radius of a cross section */
            MaxRadius: 6.0;
            /* If less than this increment, new increment will be the last valid value */
            SnapThreshold: 0.25;
            /* Whether to create shell colliders or not */
            CreateShellColliders: false;
            /* Amount of colliders per cross section */
            NumberOfCollidersPerCrossSection: 12;
            /* Measure to avoid fairings being flat or too skinny */
            MinHeightRadiusRatio: 0.07;
            /* Min allowed height per cross section */
            CrossSectionHeightMin: 0.1;
            /* Max allowed height per cross section */
            CrossSectionHeightMax: 0.7;
            /* Amount of rays per sweep. Used to determine payload intersection */
            ConeSweepRays: 120;
            /* Distance apart from each ray. Used to determine payload intersections */
            ConeSweepPrecision: 1.0;
            /* Whether an automatically generated fairing should be capped (does nothing for ConstructionType = Custom) */
            ShouldCapOnAutoGenerate: false;

            /*
              +---------------------------------+
              | Procedural Generation Tuneables |
              +---------------------------------+
            */

            /* Mass per square unit of paneling */
            MassAreaRatio: 0.0;
            /* Max amount of edges that the 3D mesh will have. More sides is more rounded but more RAM usage */
            FairingSideCount: 24;
            /* The amount of each vertical "step" increment when VAB snap is on */
            FairingLengthSnapIncrement: 0.125;
            /* The amount of each horizontal "step" increment when VAB snap is on */
            FairingRadiusSnapIncrement: 0.125;
            /* The smoothing angle of the fairing mesh, in degrees */
            FairingSmoothingAngle: 35.0;
            /* The thickness of the fairing mesh */
            FairingThickness: 0.025;
            /* Position along the fairing axis on the host part where the procedural mesh starts. Zero = part prefab origin */
            FairingStartHeight: 0.0;

            /*
              +---------------------+
              | Procedural Controls |
              +---------------------+
            */

            /* Allow change of construction mode in the PAM */
            AllowConstructionTypeChange: true;
            /* Allow change of floating node vis in the PAM */
            AllowFloatingNodeChange: true;
            /* Whether the fairing will be enabled by default */
            DefaultFairingEnabledToggle: true;
            /* Whether the fairing will have automatic construction set by default */
            DefaultAutoConstruction: true;
            /* Deploy Type set by default */
            DefaultDeployType: "Shroud";
            /* The starting state of the floating node */
            DefaultFloatingNodeState: true;
            /* The minimum distance of the Length value. Should be greater or equal to the min cross section length */
            LengthEditMinimum: 0.0;
            /* The maximum distance of the Length value */
            LengthEditMaximum: 0.001;
            /* The default distance of the Length value */
            LengthEditDefault: 0.0;
            /* Default value for the Staging toggle */
            StageToggleDefault: false;
            /* The highest part radius an auto-generated fairing should target when constructing. Part size index, [0,10] range, -1 being automatic */
            MaxAutoFairingTargetRadius: -1;
            /* The smallest part radius an auto-generated fairing should target when constructing. Part size index, [0,10] range, -1 being automatic */
            MinAutoFairingTargetRadius: -1;
        }
    }
}